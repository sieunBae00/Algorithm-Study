# [Platinum V] 이진 검색 트리 - 1539 

[문제 링크](https://www.acmicpc.net/problem/1539) 

### 성능 요약

메모리: 14752 KB, 시간: 100 ms

### 분류

자료 구조, 집합과 맵, 트리를 사용한 집합과 맵

### 제출 일자

2026년 2월 5일 02:33:58

### 문제 설명

<p>P는 크기가 N인 배열이다. P에는 0보다 크거나 같고, N-1보다 작거나 같은 정수가 중복 없이 채워져 있다. 이진 검색 트리는 루트가 있는 이진 트리로, 각각의 노드에 정수 값이 저장되어 있는 트리이다. 이진 검색 트리를 P배열을 이용해서 만드는 법은 다음과 같다. 일단 root를 만들고 거기에 P[0]의 값을 넣은 후에 다음과 같은 과정을 거친다.</p>

<pre>for (int i=1; i<=n-1; i++) {
    insert(root, P[i]);
}
</pre>

<p>여기서 insert함수는 다음과 같다.</p>

<pre>void insert(Vertex V, int X) {
    if (x < V에 저장되어 있는 수) {
        if (V가 왼쪽 자식이 있으면) {
            insert(V의 왼쪽 자식, X);
        } else {
            V의 왼쪽 자식을 새로 만들고, 그 곳에 X를 저장함
        }
    } else {
        if (V가 오른쪽 자식이 있으면) {
            insert(V의 오른쪽 자식, X);
        } else {
            V의 오른쪽 자식을 새로 만들고, 그 곳에 X를 저장함
        }
    }
}
</pre>

<p>N과, 배열 P에 있는 수가 주어졌을 때, P로 이진 검색 트리를 만들었을 때, 모든 노드의 높이의 합을 출력하는 프로그램을 작성하시오. 트리의 높이는 루트에서 부터의 거리 + 1이다.</p>

### 입력 

 <p>첫째 줄에 N이 주어진다. N은 250,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 P[0]부터 P[N-1]의 원소가 한 줄에 하나씩 들어온다.</p>

### 출력 

 <p>주어진 P배열로 이진 검색 트리를 만들었을 때, 높이의 합을 출력한다. 이 값은 2^63보다 작다.</p>

---

### Idea  

#### 처음 생각  

직접 트리를 만들어야 하나? (문제에 주어진 insert() 함수를 이용해서?)  
  
- 🛑 만약 불균형한 트리라면?  
-> 높이가 매우 높은 트리가 탄생한다... 계속 끝까지 내려가면서 탐색을 해야 하므로 시간초과,,
<br>

--> `set` (균형잡힌 BST) 를 쓸까?
<br>

🛑 그런데 set 은 트리의 균형을 잡기 위해 root 를 바꿔 버릴 것이다. set 을 직접 트리를 만드는 용도로 사용하면 안 된다.
<br>

대신...
`set` 이 자동으로 정렬된다는 점을 이용한다.  
'set 은 단지 자신의 부모가 될 가능성이 있는, `'나보다 바로 (작은 것/큰 것)'` 을 확인하기 위한 용도로 사용한다.  

> 💡 P 의 원소들이 들어올 때마다 `set` 에 넣고, 즉시 높이를 계산해서 저장한다.  
  
> (높이) = (나의 부모 노드) + 1  

> 부모 노드의 결정: 💡 `'나보다 바로 (작은 것/큰 것)'` 둘 중 하나.  
> => 둘 중 무엇?: 더 나중에 들어와서 __깊이가 더 깊은 것__ !!  
> **⚠️ 인덱스 관리 - 배열의 범위를 벗어나지 않도록 체크해야 한다 !  

---

#### ⚠️ `.insert()` 함수의 반환값  
`.insert()` 함수는 단지 인덱스 값(정수) 을 반환하지 않는다.  
set 의 내부 구현은 트리이므로, `.insert()` 는 {넣은 위치(반복자), 성공 여부} 를 반환한다.  
즉 자료형으로 쓰면 __`pair<set<int>::iterator, bool>`__ 이 된다. (그냥 `auto` 쓰자...)  

#### ⚠️ 특수한 자료형의 비교  
문제에서 `set<int>::iterator` 와 같은 자료형이 등장한다.  
int, string 과 같은 자료형은 c++ 내부에서 정수로 저장되어 `<`, `>`, `<=`, `>=` 으로 크다/작다 를 따지는 것이 가능하지만,  
`set<int>::iterator` 는 __크고 작음을 따질 수 없다.__ 따라서 `==`, `!=` 으로만 비교할 수 있다.  
