# [Platinum V] 정점들의 거리 - 1761 

[문제 링크](https://www.acmicpc.net/problem/1761) 

### 성능 요약

메모리: 9892 KB, 시간: 1736 ms

### 분류

자료 구조, 트리, 최소 공통 조상, 희소 배열

### 제출 일자

2026년 1월 30일 02:54:23

### 문제 설명

<p>N(2 ≤ N ≤ 40,000)개의 정점으로 이루어진 트리가 주어지고 M(1 ≤ M ≤ 10,000)개의 두 노드 쌍을 입력받을 때 두 노드 사이의 거리를 출력하라.</p>

### 입력 

 <p>첫째 줄에 노드의 개수 N이 입력되고 다음 N-1개의 줄에 트리 상에 연결된 두 점과 거리를 입력받는다. 그 다음 줄에 M이 주어지고, 다음 M개의 줄에 거리를 알고 싶은 노드 쌍이 한 줄에 한 쌍씩 입력된다. 두 점 사이의 거리는 10,000보다 작거나 같은 자연수이다.</p>

<p>정점은 1번부터 N번까지 번호가 매겨져 있다.</p>

### 출력 

 <p>M개의 줄에 차례대로 입력받은 두 노드 사이의 거리를 출력한다.</p>

---
### Idea

#### 처음 생각
처음엔 알고자 하는 노드 쌍 사이의 거리를 매번 탐색하도록 했다. 따라서 visited 배열도 M 번 초기화해야 했다.  
  
- 🛑 Q. 과연 최대 4만개 배열을 M번 초기화해도 시간초과가 안 날까?  
--> 난다... 시간초과가 나. 게다가 더 큰 문제는...  

> __'탐색'__ 방식에도 문제가 있다.  
> N개 정점, 거리를 알고자 하는 노드 쌍이 M개 --> 탐색에 O(N*M) 이 걸린다. (시간초과)  

---

#### '탐색' 과정 줄이기.  

1. root 노드를 기준으로 한 각 노드의 거리표를 만들어 둔다.   
이렇게 하면 노드 쌍 `(A, B)` 의 거리를 매번 일일히 탐색할 필요 없다.  
> 💡 `(1 -> A)` 의 거리, `(1 -> B)` 의 거리를 알고 __'`A` 와 `B` 가 나뉘는 지점'(최소공통조상)__ 을 알면   
> 간단한 수식만으로 `(A -> B)` 로의 거리를 구할 수 있다.  
> `(A -> B)` = `{(1 -> A) + (1 -> B)} - 2 * (1 -> 최소공통조상)`  
<br>

2. 최소 공통 조상(LCA) 찾는 함수 ..⭐  
🛑 그럼 최소 공통 조상(LCA) 는 어떻게 찾을 것인가?  
  
> 💡 ** `LCA` 를 찾기 위해서는 먼저 각 노드의 __깊이(`depth`)를 구해서 저장__ 해두어야 한다.!!  
> (깊이가 더 깊은 노드를 올리면서 깊이를 맞춰가야 하는데, 깊이를 모르면 불가능)  
<br>
사실.. 깊이를 하나씩 올리면서 LCA를 찾는 방식도 시간 초과가 날 것 같았는데,  
테스트 케이스가 착했는지 다행히 통과는 했다.  
(불균형한 트리의 경우, 트리의 높이가 4만이 되어 LCA 찾을 때마다 4만 번 반복해야 할 수도...)  
