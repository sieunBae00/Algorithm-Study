# [Gold IV] 거짓말 - 1043 

[문제 링크](https://www.acmicpc.net/problem/1043) 

### 성능 요약

메모리: 2020 KB, 시간: 0 ms

### 분류

자료 구조, 그래프 이론, 그래프 탐색, 분리 집합

### 제출 일자

2026년 2월 21일 00:47:01

### 문제 설명

<p>지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 이런 일을 모두 피해야 한다.</p>

<p>사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 사람의 수 N과 파티의 수 M이 주어진다.</p>

<p>둘째 줄에는 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고 그 개수만큼 사람들의 번호가 주어진다. 사람들의 번호는 1부터 N까지의 수로 주어진다.</p>

<p>셋째 줄부터 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다.</p>

<p>N, M은 50 이하의 자연수이고, 진실을 아는 사람의 수는 0 이상 50 이하의 정수, 각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수이다.</p>

### 출력 

 <p>첫째 줄에 문제의 정답을 출력한다.</p>

---
### Idea

#### 처음 생각

처음엔 '이게 왜 그래프 문제지..?' 했는데, 알고보니 문제 이해를 잘못한 것이었다.
</br>
지민이는 이야기가 하나밖에 없다. 하나의 이야기에 대해서 진실/거짓 을 말하는 것.  
따라서 만약 진실을 모르던 사람이 파티에서 진실을 듣는다면, __그 사람도 "진실 그룹"에 포함시켜야__ 한다.  
</br>

예제 입/출력을 보다 보니 또 이해 안 가는 부분이 있었는데, 이 역시도 내가 생각을 잘못한 것이었다.  
``` text
에제 입력 4
4 5
1 1
1 1
1 2
1 3
1 4
2 4 1
```
``` text
예제 출력 4
2
```

위에서, 나는 거짓말을 할 수 있는 경우는 2, 3, 4 번 사람을 만나는 2, 3, 4 번쨰 파티에서 거짓말이 가능할 것이라고 생각했다. 그런데 왜 출력은 2일까?  
그것은 1번, 4번을 만나는 마지막 파티에서 4번이 지민이가 거짓말한 사실을 알아채기 때문이다!  
즉, 같은 사람을 추후 다른 파티에서 만날 가능성을 고려해 말이 바뀌지 않도록 해야 한다.  
--> 따라서 '모든 파티가 끝난 후' 의 '진실 그룹'을 미리 계획해야 한다. (union)  
(결과적으로 처음부터 진실을 아는 사람과 파티에서 한 번도 마주치치 않는 사람 만이 거짓말을 들을 수 있게 된다)  
(*파티 정보를 다시 살펴봐야 하므로, 저장해 두어야 한다.)  

---

#### 구현

구현도 약간 새로운... 그러나 익숙한... 문제.  
`union-find` 를 사용한다. 자료구조 시간에 들었던 기억이 난다.  
`union-find` 는 노드/간선 을 저장하는 2차원 배열이 아닌, __1차원 배열만으로 연결 상태를 나타내는__ 방법이다.  
(다만 모든 정보를 저장할 수는 없고, '같은 그룹인지' 를 파악하기에 용이하다)   
개념은 특별히 어렵지 않다. 구현을 해본 적이 없어서 그렇지.  


``` text 
처음부터 진실을 아는 사람 = 0
한 파티에서 만나는 사람들끼리 '보스 대결' 을 한다. 누가누가 더 작나. (0번이 이기도록 하기 위함)
진 사람들은 이긴 사람을 자신의 보스로 저장한다. (union)
계속해서 대결을 하다 보면, 진실을 알아야 하는 사람들의 최종 보스는 모두 0이 된다.
---
모든 파티를 순회하며, 파티의 참석하는 사람의 최종 보스가 0인지를 확인한다. (find)
0이 아닌 경우 거짓말이 가능하다.
```

- 🛑 말단 노드(`Truth[a]`, `Truth[b]`)를 직접 수정하면 안 된다.
> `Union` 과정에서 말단 노드의 `boss` 를 직접 변경하게 되면, 해당 노드 하나만 다른 그룹으로 이동하게 된다. (x)  
> 💡 Union-Find의 목적은 개인이 아닌 **그룹 전체의 병합** 이다.  
> 반드시 각 말단의 '최종 보스'끼리 연결해야, 전체 그룹이 통째로 병합된다.  
</br>

- 🛑 시간 초과
  코드를 제출했는데, 시간 초과가 발생했다. 자료구조 자체의 문제는 아니고, 예외처리를 하지 않아 __무한루프__ 에 빠진 것이었다.  
  무한 루프가 발생한 이유는 병합(`union`) 과정에서 사이클(`cycle`) 이 발생했기 때문이다.
  
  [문제의 코드]
```cpp
void Union(int a, int b) {
    // ❌ 매번 find()를 호출, 예외 처리가 없음
    if (find(a) < find(b)) Truth[b] = a;
    else Truth[a] = b;
}
```

> 위 코드에서는 `find(a) == find(b)` 일 경우에 대한 예외 처리를 하지 않고 있다. 
> (💡 둘이 같은 경우, __이미 같은 그룹이므로 아무것도 하지 않아도 된다__ !!)  
> 또한, 매번 `find()` 를 호출하면 시간 낭비가 일어나므로, `find(a)`, `find(b)` 를 저장해 두고 두 값을 비교하는 방식으로 코드를 수정한다.  

