# [Gold I] 트리의 순회 - 2263 

[문제 링크](https://www.acmicpc.net/problem/2263) 

### 성능 요약

메모리: 6192 KB, 시간: 16 ms

### 분류

트리, 분할 정복, 재귀

### 제출 일자

2026년 1월 30일 03:41:23

### 문제 설명

<p>n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 줄에는 인오더를 나타내는 n개의 자연수가 주어지고, 그 다음 줄에는 같은 식으로 포스트오더가 주어진다.</p>

### 출력 

 <p>첫째 줄에 프리오더를 출력한다.</p>

---

### Idea  

#### 처음생각  

- 반드시 inorder, postorder 둘을 다 알아야 preorder 를 알 수 있나?  

--> 이 문제에서는 그렇다. 트리의 모양이 정해지지 않았기 떄문.  
(이전 `9934 완전이진트리` 에서는 항상 포화이진트리가 주어져서 순회 결과 하나만으로도 트리를 구성하는 것이 가능했다, 이것과 헷갈림.)  

#### 중위순회, 후위순회의 특징?
- 중위순회: 루트 노드를 가운데에 방문한다.... 그러나 여기선 트리의 모양을 모르므로 정확히 반으로 나눌 수 x.  
--> 중위 순회는 __"포화 이진 트리일 때"__ 루트 노드를 정확히 가운데에 방문한다.  
- 후위순회: __"가장 마지막"__ 이 루트 노드이다. 이건 트리 모양에 관계없이 확실.  

> 💡 후위순회로 루트를 알아낸다. -> 이후 중위 순회로 양쪽 서브트리의 크기를 알아낸다. -> 다시 후위 순회로 양쪽 서브트리의 루트를 알아내고 ... (반복)

---
#### 고난의 연속(삽질의 시작)

- 🛑 구현이 뭔가... 어려움. 어떻게 짜지? ...  
  
일단 처음엔 한 함수로 짤까 하다가, 다시 중위/후위 순회 각각 만들까 하다가, 인덱스 넘기기가 너무 어려운 것 같아서 관둠.  
--> 다시 함수 하나로 도전 ,,  

> solve 함수: 루트 알아내기 -> 서브트리 크기 알아내기 -> 양쪽 서브트리에 대하여 재귀! (<- 시작, 끝 범위를 넘겨주기!!)
<br>

- 🛑 중위 순회는 `flag` 기준 인덱스가 나눠지겠는데, 후위 순회는 인덱스를 어떻게 전달하나?  
> 💡 __배열의 크기는 변하지 않는다!!__ 인덱스 자체보다, 배열의 사이즈(크기)로 접근하기.  
  __Inorder:__ `[ 왼쪽 자식들 ]` `(루트)` `[ 오른쪽 자식들 ]`  
  __Postorder:__ `[ 왼쪽 자식들 ]` `[ 오른쪽 자식들 ]` `(루트)`  
--> 따라서, (Inorder 배열의 `[ 왼쪽 자식들 ]` 의 크기) 는 (Postorder 배열의 `[ 왼쪽 자식들 ]` 의 크기) 와 같다 !!
<br>

- 🛑 인덱스의 이해
중위 순회, 후위 순회 배열의 구조를 제대로 이해해야 한다.  
이해는 가도 확신은 안 드는 느낌?,, 덕분에 끝까지 인덱스 때문에 삽질했다..^^  
> ⭐ 재귀를 돌며 __내가 target 하는 배열의 범위가 작아져도, 배열의 구조는 그대로 유지된다!!__ (<- 재귀를 돌 수 있는 이유!!)
<br>


- 🛑 종결조건 설정은 어떻게?  
재귀를 돌며 다음으로 전달되는 배열의 크기는 일정하게/하나씩 감소하지 않는다.  
+다음으로 전달되는 배열 크기가 1일 때, 즉 `in_start == in_end` 이거나 `post_start == post_end` 일 경우 까지는 출력을 해야 한다.  
(그 자체로 노드 하나를 담당)
<br>


- ⚠️ 종결 조건이 다음과 같은 것에 의문을 가졌다.  

`if ((in_end < in_start) || (post_end < post_start)) return;`  

의문) 왜 "and" 이지? 다른 쪽은 배열의 크기가 1이 아니고 아직 남아 있는 경우는?  
--> 그러나 나의 어리석음에서 비롯된... 사소한 오해였다.  
사실 인덱스 계산을 제대로 했다면, __`inorder` 배열의 크기와 `postorder` 배열의 크기는 같아야 한다.__ (앞에서 했던 얘기. 배열의 사이즈는 같다)

<br>

---
#### ⚠️ 시간초과 예방하기  
테스트 데이터가 착했는지 통과되긴 했지만, 사실 `inorder` 배열을 하나씩 돌며 `root` 를 찾는 건 시간 낭비가 심한 방법이다.  
(트리가 편향된 경우, 매번 배열 끝까지 `for` 문을 돌려야 할 수도 있다)  
> 💡 inorder 배열의 값에 따른 위치(인덱스)를 저장하는 __"위치 저장 배열(`position`)"__ 을 하나 만든다.  
> (노드 번호가 `1~n` 까지이므로 가능)  
<br>
이후 `solve()` 함수 내에서는 `for` 문을 삭제하고,  
`int flag = position[root];`  
와 같이 사용해 시간복잡도를 `O(1)` 로 줄일 수 있다!!  
