# [Silver I] 나무 탈출 - 15900 

[문제 링크](https://www.acmicpc.net/problem/15900) 

### 성능 요약

메모리: 42168 KB, 시간: 224 ms

### 분류

그래프 이론, 그래프 탐색, 트리, 깊이 우선 탐색

### 제출 일자

2026년 1월 28일 23:08:11

### 문제 설명

<p>평소에 사이가 좋지 않던 성원이와 형석이가 드디어 제대로 한 판 붙으려고 한다. 성원이와 형석이 둘과 모두 똑같이 친한 인섭이가 대결 종목을 정해 가져왔다. 바로 '나무 탈출' 이라는 보드게임이다.</p>

<p>'나무 탈출' 은 N개의 정점이 있는 트리 모양으로 생긴 게임판과 몇 개의 게임말로 이루어진다. 트리의 각 정점에는 1번부터 N번까지 번호가 붙어있다. 1번 정점은 '루트 노드' 라고 불리며, 이 루트 노드를 중심으로 정점 간에 부모-자식 관계가 만들어진다. 자식이 없는 노드는 '리프 노드' 라고 불린다.</p>

<p>이 게임은 두 사람이 번갈아 가면서 게임판에 놓여있는 게임말을 움직이는 게임이다. 처음에는 트리의 모든 리프 노드에 게임말이 하나씩 놓여있는 채로 시작한다. 어떤 사람의 차례가 오면, 그 사람은 현재 존재하는 게임말 중 아무거나 하나를 골라 그 말이 놓여있던 노드의 부모 노드로 옮긴다. 이 과정에서 한 노드에 여러 개의 게임말이 놓이게 될 수도 있다. 이렇게 옮긴 후에 만약 그 게임말이 루트 노드에 도착했다면 그 게임말을 즉시 제거한다. 모든 과정을 마치면 다음 사람에게 차례를 넘긴다. 이런 식으로 계속 진행하다가 게임말이 게임판에 존재하지 않아 고를 수 없는 사람이 지게 된다.</p>

<p>성원이를 얕본 형석이는 쿨하게 이 게임의 선을 성원이에게 줘버렸다. 따라서 성원이가 먼저 시작하고 형석이가 나중에 시작한다. 그동안 형석이와 대결을 하면 매번 지기만 했던 성원이는 마음속에 분노가 가득 쌓였다. 이번 대결에서는 반드시 이겨서 형석이의 코를 꺾어주고 싶다. 그래서 게임을 시작하기 전에 게임판의 모양만 보고 이 게임을 이길 수 있을지 미리 알아보고 싶어졌다. 성원이가 이 게임을 이길 수 있을지 없을지를 알려주는 프로그램을 만들어 성원이를 도와주자.</p>

### 입력 

 <p>첫째 줄에 트리의 정점 개수 N(2 ≤ N ≤ 500,000)이 주어진다.</p>

<p>둘째 줄부터 N-1줄에 걸쳐 트리의 간선 정보가 주어진다. 줄마다 두개의 자연수 a, b(1 ≤ a, b ≤ N, a ≠ b)가 주어지는데, 이는 a와 b 사이에 간선이 존재한다는 뜻이다.</p>

### 출력 

 <p>성원이가 최선을 다했을 때 이 게임을 이길 수 있으면 <code>Yes</code>, 아니면 <code>No</code>를 출력한다.</p>

---
### Idea

#### 문제 분석

처음 생각: 베스킨라빈스31 게임 이기는 법...? 그러나 그것보다는 훨씬 간단한 문제였던 것 같다.  
<br>
- 간선은 어떻게 저장할 것인가?   
간선이 주어질 떄 누가 부모인지는 주어지지 않으므로, 트리의 부모 노드를 저장하는 배열을 만드는 것은 어려울 듯 하다.  
--> 그냥 간선을 양쪽에 저장하자. (`2차원 배열`)  

> 💡루트 노드가 아닌 모든 노드에 대하여, __'연결된 간선이 하나이면' 반드시 리프 노드이다.__   
> (루트 노드를 제외하면, 어떤 노드에 연결된 간선 하나는 반드시 부모 노드이므로)  


- 🛑 `(리프 노드) ~ (루트 노드)` 까지의 거리를 어떻게 계산?  

트리에서는, `(어떤 노드) ~ (다른 노드)`까지의 경로가 __딱 하나__ 밖에 없다.  
top-down / bottom-up 을 고민했는데, bottom-up으로 시도했다. (그러나 결과는...)  
<br>
리프 노드에서 출발해, 루트를 찾아가고, 루트를 발견하면 건너 온 거리를 `ans` 에 더하도록 했다.  
그러나....  

---

#### 🛑 시간 초과  

위의 bottom-up 방식은 시간 초과로 실패했다.  
정점 수가 최대 `50만 개`라, 리프 노드 수만큼 for 문을 돌며 `visited` 배열을 초기화하면 그것만으로도 시간이 터진다.  

--> top-down 으로 변경하기로 했다.  

> 💡top-down 방식을 쓰면, `DFS(또는 BFS)` 함수를 __한 번 도는 것만으로__ 모든 리프 노드의 깊이를 알 수 있다.  
> (처음엔 왜 top-down도 여러 번 돌아야 한다고 생각했을까...)  
  
리프 노드인지 저장하는 `bool` 타입의 `isLeaf ` 배열을 새롭게 만들었다.   
`DFS`과정(`findLeaf()` 함수)을 수행하며, 리프 노드라면 건너온 거리를 `ans` 에 더하도록 했다.  

> 💡 `findLeaf()` 에서 '지금까지의 거리'를 함께 매개변수로 넘겨준다.  
> (`ans` 에 직접 거리를 더하지 않도록 한다. 리프 노드가 확인되었을 때에만 거리를 한꺼번에 `ans` 에 더한다.)  
이전 문제에서도 이것 때문에 애먹었는데, 이번엔 다행히 빨리 생각해낼 수 있었다.
