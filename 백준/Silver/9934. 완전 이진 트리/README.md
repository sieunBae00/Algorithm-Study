# [Silver I] 완전 이진 트리 - 9934 

[문제 링크](https://www.acmicpc.net/problem/9934) 

### 성능 요약

메모리: 2208 KB, 시간: 0 ms

### 분류

트리, 재귀

### 제출 일자

2026년 1월 28일 00:03:54

### 문제 설명

<p>상근이는 슬로베니아의 도시 Donji Andrijevci를 여행하고 있다. 이 도시의 도로는 깊이가 K인 완전 이진 트리를 이루고 있다. 깊이가 K인 완전 이진 트리는 총 2<sup>K</sup>-1개의 노드로 이루어져 있다. (아래 그림) 각 노드에는 그 곳에 위치한 빌딩의 번호가 붙여져 있다. 또, 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2f3d1f78-7ef1-4be4-868c-6172f57f2db6/-/preview/" style="width: 429px; height: 147px;"></p>

<p style="text-align: center;">깊이가 2와 3인 완전 이진 트리</p>

<p>상근이는 도시에 있는 모든 빌딩에 들어갔고, 들어간 순서대로 번호를 종이에 적어 놓았다. 한국으로 돌아온 상근이는 도시가 어떻게 생겼는지 그림을 그려보려고 하였으나, 정확하게 기억이 나지 않아 실패했다. 하지만, 어떤 순서로 도시를 방문했는지 기억해냈다.</p>

<ol>
	<li>가장 처음에 상근이는 트리의 루트에 있는 빌딩 앞에 서있다.</li>
	<li>현재 빌딩의 왼쪽 자식에 있는 빌딩에 아직 들어가지 않았다면, 왼쪽 자식으로 이동한다.</li>
	<li>현재 있는 노드가 왼쪽 자식을 가지고 있지 않거나 왼쪽 자식에 있는 빌딩을 이미 들어갔다면, 현재 노드에 있는 빌딩을 들어가고 종이에 번호를 적는다.</li>
	<li>현재 빌딩을 이미 들어갔다 온 상태이고, 오른쪽 자식을 가지고 있는 경우에는 오른쪽 자식으로 이동한다.</li>
	<li>현재 빌딩과 왼쪽, 오른쪽 자식에 있는 빌딩을 모두 방문했다면, 부모 노드로 이동한다.</li>
</ol>

<p>왼쪽 그림에 나와있는 마을이라면, 상근이는 2-1-3 순서대로 빌딩을 들어갔을 것이고, 오른쪽 그림의 경우에는 1-6-4-3-5-2-7 순서로 들어갔을 것이다. 상근이가 종이에 적은 순서가 모두 주어졌을 때, 각 레벨에 있는 빌딩의 번호를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 K (1 ≤ K ≤ 10)가 주어진다.</p>

<p>둘째 줄에는 상근이가 방문한 빌딩의 번호가 들어간 순서대로 주어진다. 모든 빌딩의 번호는 중복되지 않으며, 구간 [1,2<sup>K</sup>)에 포함된다.</p>

### 출력 

 <p>총 K개의 줄에 걸쳐서 정답을 출력한다. i번째 줄에는 레벨이 i인 빌딩의 번호를 출력한다. 출력은 왼쪽에서부터 오른쪽 순서대로 출력한다.</p>

---
### Idea  
  
#### 문제 분석  
주어지는 트리는 깊이 `K`, 총 노드 `2^K -1`인 포화이진트리 이다.
또한 상근이는 빌딩을 중위 순회로 방문한다.  
> 즉, 중위 순회한 결과가 주어졌을 때 트리를 레벨별로 출력하는 문제이다.
  
#### 처음 생각들:

- 입력받는 중위 순회 순서를 배열에 저장한 뒤, 각 레벨과 인덱스 번호와의 관계를 수식적으로 나타내서, 조건에 맞는 인덱스일 때 정답 배열에 따로 저장

- 혹은.. 레벨별로 나타내는 거니까 BFS?

- 혹은.. 왼쪽 자식/오른쪽 자식의 인덱스 표현?

---
일단 첫 번째로 시도. 다행히 해결 가능했다.
  
  
- 🛑레벨 - 인덱스 간의 관계를 어떻게 나타낼 것인가?

> 💡 중위 순회하면 항상 __루트를 맨 중간에 방문__ 한다.

  
- top-down / bottom-up ?  
  
일단 bottom-up 으로 시도했다.  

> 높이(i)가 1인 노드의 인덱스 (=리프 노드의 인덱스): 홀수. `2n-1` (n=1,2,3...)  
> 높이(i)가 2인 노드의 인덱스: `4n-2` (n=1,2,3...)  
> 높이(i)가 3인 노드의 인덱스: `8n-4` (n=1,2,3...)  
> ...  
  
이런 식으로, 높이(i)가 1씩 증가함에 따라 `공차(d)`와 `첫째항(a)`이 각각 두 배가 되는 등차수열의 일반항으로 표현 가능하다.  
높이가 1일 때 `a = 1`, `d = 2` 라 하면,  
> 높이가 K인 노드의 인덱스는 `(d*K)n - a*K` 로 일반화할 수 있다.  
  
> 현재의 인덱스 번호가 `(d*K)n - a*K`에 해당하는지 확인하기 위해서는  
> 💡 `if( (인덱스) + a*K % (d*K) == 0 )` 로 확인 가능하다.  

  
---
이 방법은 수식까지만 도출해 내면 쉽게 구현이 가능하다.  
⚠️한편 이 방법의 단점은 깊이가 K이면 `(2^K -1)` 크기의 배열을 일일히 K번 돌아야 한다는 것이다.  
다행히 이 문제에서는 K = 10 이 최대였기에 가능했다. (배열 크기 최대 1023)
  
---
#### 주의점⚠️
VisualStudio2022 에서는 `#include <cmath>` 를 쓰지 않아도 `pow()` 함수가 잘 돌아갔다.  
(내부에서 사용되는 MSVC 컴파일러가 알아서 포함시켜 주기 때문이라고 한다)   
그러나 백준 채점 서버는 라이브러리 표준을 정확하게 지키므로 이에 주의하자. (`#include <cmath>` 생략 시 컴파일 에러 발생)
